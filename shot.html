<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR 手势射击 - 磁吸瞄准版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        /* 视频层：隐藏，但需要存在以供AI分析 */
        #input-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; opacity: 0; pointer-events: none; transform: scaleX(-1); }
        /* 游戏层：Three.js 画布 */
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
        /* UI 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        .hud-text { position: absolute; color: #00ffcc; font-weight: bold; text-shadow: 0 0 5px #00ffcc; }
        #score-board { top: 20px; left: 20px; font-size: 24px; }
        #status-board { top: 20px; right: 20px; font-size: 18px; text-align: right; }
        
        /* 浮动文字特效 */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-size: 30px;
            animation: floatUp 0.8s ease-out forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* 加载遮罩 */
        #loading-mask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white;
            transition: opacity 0.5s; pointer-events: auto;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid #00ffcc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading-mask">
        <div class="spinner"></div>
        <div id="loading-text">正在初始化神经网络...<br>请允许摄像头权限</div>
    </div>

    <video id="input-video" playsinline></video>
    <canvas id="game-canvas"></canvas>
    
    <div id="ui-layer">
        <div id="score-board" class="hud-text">SCORE: 0</div>
        <div id="status-board" class="hud-text">
            SYSTEM: ONLINE<br>
            FPS: <span id="fps-counter">60</span>
        </div>
    </div>

<script>
/**
 * 核心配置与防报错常量
 */
const MP_VERSION = '0.4.1646424915';
const MP_CDN = `https://unpkg.com/@mediapipe/hands@${MP_VERSION}/`;
// 限制 AI 检测帧率，节省性能给渲染
const AI_INTERVAL = 3; // 每 3 帧执行一次手势检测

// 游戏状态
const state = {
    score: 0,
    isLoaded: false,
    width: window.innerWidth,
    height: window.innerHeight,
    frameCount: 0,
    lastTime: 0,
    hand: { x: 0.5, y: 0.5, isTriggered: false, lastTriggerTime: 0 },
    enemies: [],
    particles: []
};

// 元素引用
const el = {
    video: document.getElementById('input-video'),
    canvas: document.getElementById('game-canvas'),
    loading: document.getElementById('loading-mask'),
    loadingText: document.getElementById('loading-text'),
    ui: document.getElementById('ui-layer'),
    score: document.getElementById('score-board'),
    fps: document.getElementById('fps-counter')
};

// 音频上下文
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

/**
 * Three.js 初始化
 */
const scene = new THREE.Scene();
// 摄像机设置为正交透视混合感觉，或者透视投影
const camera = new THREE.PerspectiveCamera(75, state.width / state.height, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ canvas: el.canvas, alpha: true, antialias: true }); // alpha: true 让背景透明显示摄像头
renderer.setSize(state.width, state.height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// 灯光
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(0, 10, 10);
scene.add(dirLight);

/**
 * 游戏对象工厂
 */
// 准心 (激光准星)
const cursorGroup = new THREE.Group();
const cursorRing = new THREE.Mesh(
    new THREE.RingGeometry(0.15, 0.18, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.8 })
);
const cursorDot = new THREE.Mesh(
    new THREE.CircleGeometry(0.03, 16),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
cursorGroup.add(cursorRing);
cursorGroup.add(cursorDot);
scene.add(cursorGroup);

// 激光指示线
const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -2, 4), new THREE.Vector3(0, 0, 0)]);
const laserMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.3 });
const laserLine = new THREE.Line(laserGeo, laserMat);
scene.add(laserLine);

// 敌人材质
const enemyGeo = new THREE.IcosahedronGeometry(0.5, 1);
const enemyMat = new THREE.MeshPhongMaterial({ color: 0xff3366, flatShading: true });

function spawnEnemy() {
    const mesh = new THREE.Mesh(enemyGeo, enemyMat.clone());
    // 随机边缘生成
    const side = Math.floor(Math.random() * 4);
    let x, y;
    const spread = 8;
    switch(side) {
        case 0: x = -spread; y = (Math.random()-0.5)*spread; break; // 左
        case 1: x = spread; y = (Math.random()-0.5)*spread; break; // 右
        case 2: x = (Math.random()-0.5)*spread; y = spread; break; // 上
        case 3: x = (Math.random()-0.5)*spread; y = -spread; break; // 下
    }
    
    mesh.position.set(x, y, -10); // 从深处飞来
    mesh.userData = { 
        velocity: new THREE.Vector3(-x * 0.005, -y * 0.005, 0.05), // 飞向中心
        rotSpeed: Math.random() * 0.1
    };
    scene.add(mesh);
    state.enemies.push(mesh);
}

/**
 * MediaPipe 初始化 (严格版本控制)
 */
async function initMediaPipe() {
    el.loadingText.innerHTML = "正在下载 AI 模型...<br>(约 10MB，请稍候)";
    
    const hands = new Hands({locateFile: (file) => {
        // 关键：强制使用 unpkg 指定版本，防止 WASM 路径错误
        return `${MP_CDN}${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandsResults);

    // 自定义 Camera Loop，用于控制 AI 检测频率
    const cameraUtils = new Camera(el.video, {
        onFrame: async () => {
            if (!state.isLoaded) return;
            state.frameCount++;
            // 性能优化：每 N 帧才跑一次重型 AI 检测
            if (state.frameCount % AI_INTERVAL === 0) {
                try {
                    await hands.send({image: el.video});
                } catch (e) {
                    console.error("AI Detect Error:", e);
                }
            }
        },
        width: 640,
        height: 480
    });

    await cameraUtils.start();
}

/**
 * 手势处理逻辑
 */
function onHandsResults(results) {
    // 首次加载成功，关闭遮罩
    if (!state.isLoaded) {
        state.isLoaded = true;
        el.loading.style.opacity = 0;
        setTimeout(() => el.loading.style.display = 'none', 500);
        // 初始化敌人
        for(let i=0; i<4; i++) spawnEnemy();
    }

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // 关键点：5=食指根部, 8=食指尖, 4=大拇指尖
        const indexTip = landmarks[8];
        const indexBase = landmarks[5];
        const thumbTip = landmarks[4];

        // 1. 简单的手部坐标映射 (0-1 -> -1到1)
        // 注意：视频是镜像的，x 轴需要反转
        const rawX = 1 - indexTip.x; 
        const rawY = 1 - indexTip.y;

        // 2. 触发器检测 (大拇指尖靠近食指根部)
        // 计算 4 和 5 之间的欧几里得距离
        const triggerDist = Math.hypot(thumbTip.x - indexBase.x, thumbTip.y - indexBase.y);
        const isTriggered = triggerDist < 0.08; // 阈值需要根据实际情况微调

        // 更新状态
        state.hand.targetX = (rawX * 2 - 1) * 8; // 映射到 3D 空间大概范围
        state.hand.targetY = (rawY * 2 - 1) * 6; // 映射到 3D 空间大概范围 (注意Y轴反转)
        
        // 射击防抖 (简单的状态机)
        if (isTriggered && !state.hand.isTriggered) {
            const now = Date.now();
            if (now - state.hand.lastTriggerTime > 300) { // 射击冷却
                fireShot();
                state.hand.lastTriggerTime = now;
            }
        }
        state.hand.isTriggered = isTriggered;
    }
}

/**
 * 核心游戏逻辑：射击与磁吸
 */
function fireShot() {
    playSound('shoot');
    
    // 视觉反馈：准心放大
    cursorRing.scale.set(1.5, 1.5, 1);
    setTimeout(() => cursorRing.scale.set(1, 1, 1), 100);

    // 碰撞检测
    // 将准心位置转为屏幕坐标用于 Raycaster (简化：直接对比 3D 距离)
    let hit = false;
    const hitThreshold = 1.2; // 击打判定半径

    for (let i = state.enemies.length - 1; i >= 0; i--) {
        const enemy = state.enemies[i];
        // 计算准心(z=0) 和 敌人(z=various) 在屏幕投影层面的距离
        // 简单做法：只比较 xy，因为准心是投影过去的
        const dist = Math.hypot(enemy.position.x - cursorGroup.position.x, enemy.position.y - cursorGroup.position.y);
        
        if (dist < hitThreshold) {
            // HIT!
            createFloatingText("HIT!", enemy.position.x, enemy.position.y, '#00ff00');
            playSound('hit');
            
            scene.remove(enemy);
            state.enemies.splice(i, 1);
            state.score += 100;
            el.score.innerText = `SCORE: ${state.score}`;
            
            spawnEnemy(); // 立刻补位
            hit = true;
            break; // 一次只打一个
        }
    }

    if (!hit) {
        createFloatingText("MISS", cursorGroup.position.x, cursorGroup.position.y, '#ff3333');
    }
}

// 磁吸辅助逻辑
function updateAimAssist() {
    let closestDist = Infinity;
    let closestEnemy = null;
    const magnetRadius = 3.0; // 磁吸生效范围

    // 原始手势位置
    let currentX = cursorGroup.position.x;
    let currentY = cursorGroup.position.y;
    
    // 平滑跟随手势
    if (state.hand.targetX !== undefined) {
        currentX += (state.hand.targetX - currentX) * 0.2;
        currentY += -(state.hand.targetY - -currentY) * 0.2; // Y轴修正
    }

    // 寻找最近敌人
    state.enemies.forEach(enemy => {
        const dist = Math.hypot(enemy.position.x - currentX, enemy.position.y - currentY);
        if (dist < magnetRadius && dist < closestDist) {
            closestDist = dist;
            closestEnemy = enemy;
        }
    });

    // 如果在磁吸范围内，准心被吸附过去
    if (closestEnemy) {
        const strength = 0.3; // 吸附力度 0-1
        currentX += (closestEnemy.position.x - currentX) * strength;
        currentY += (closestEnemy.position.y - currentY) * strength;
        cursorRing.material.color.setHex(0xff0000); // 锁定变红
    } else {
        cursorRing.material.color.setHex(0x00ffcc); // 正常青色
    }

    cursorGroup.position.set(currentX, currentY, 0);
    
    // 更新激光线
    // 激光起点：屏幕下方中间 (模拟手持位置) -> 终点：准心
    const positions = laserLine.geometry.attributes.position.array;
    // 起点固定在右下侧模拟持枪手位
    positions[0] = 2; positions[1] = -3; positions[2] = 2; 
    // 终点
    positions[3] = currentX; positions[4] = currentY; positions[5] = 0;
    laserLine.geometry.attributes.position.needsUpdate = true;
}

/**
 * 渲染循环
 */
function animate(time) {
    requestAnimationFrame(animate);

    // FPS 计算
    if (time - state.lastTime >= 1000) {
        state.lastTime = time;
    }

    // 1. 更新瞄准
    updateAimAssist();

    // 2. 更新敌人
    state.enemies.forEach(enemy => {
        enemy.position.add(enemy.userData.velocity);
        enemy.rotation.x += enemy.userData.rotSpeed;
        enemy.rotation.y += enemy.userData.rotSpeed;

        // 敌人飞到眼前重置
        if (enemy.position.z > 2) {
            enemy.position.z = -10;
            enemy.position.x = (Math.random()-0.5) * 10;
            enemy.position.y = (Math.random()-0.5) * 10;
        }
    });

    // 3. 渲染
    renderer.render(scene, camera);
}

/**
 * 工具函数：浮动文字
 */
function createFloatingText(text, x, y, color) {
    // 将 3D 坐标转为 2D 屏幕坐标
    const vector = new THREE.Vector3(x, y, 0);
    vector.project(camera);

    const cx = (vector.x * .5 + .5) * state.width;
    const cy = (-(vector.y * .5) + .5) * state.height;

    const div = document.createElement('div');
    div.className = 'float-text';
    div.innerText = text;
    div.style.color = color;
    div.style.left = `${cx}px`;
    div.style.top = `${cy}px`;
    el.ui.appendChild(div);

    setTimeout(() => div.remove(), 800);
}

/**
 * 工具函数：合成音效 (避免加载外部资源)
 */
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'hit') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
    }
}

// 窗口大小调整
window.addEventListener('resize', () => {
    state.width = window.innerWidth;
    state.height = window.innerHeight;
    camera.aspect = state.width / state.height;
    camera.updateProjectionMatrix();
    renderer.setSize(state.width, state.height);
});

// 启动
window.onload = () => {
    // 现代浏览器需要用户交互才能播放 Video/Audio
    document.body.addEventListener('click', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }, {once:true});
    
    initMediaPipe();
    animate();
};

</script>
</body>
</html>